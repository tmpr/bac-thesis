\documentclass{article}

% -- Packages
\usepackage[utf8]{inputenc}
\usepackage{biblatex}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{microtype}
\usepackage{pdfpages}
\usepackage{{booktabs}}
\usepackage{{multirow}}
\usepackage{geometry}
\usepackage{bookmark}
\usepackage{multicol}
\usepackage{mathtools}

% -- Theorem environments
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{remark}{Remark}
% -- Document Settings
\emergencystretch=1em
\title{Deriving BLOSUM-like matrices for protein-coding DNA}
\geometry{a4paper, left=20mm, right=20mm, top=20mm, bottom=30mm}
\addbibresource{substitution-matrices.bib}
\author{Alexander Temper}

\begin{document}
\maketitle

\begin{abstract}
    Sequence Alignment algorithms rely on some form of scoring matrix,
    which can heavily influence their results. In this work, we try to derive a
    scoring matrices for the genes of subsets of protein families akin to
    the BLOSUMx matrices, which are used for amino acid sequences.
\end{abstract}

\begin{multicols}{2}

\section*{Introduction} Sequence alignment is the task of pairing up the
elements of two (biological) sequences with the aim of finding conserved
regions and homologous sequences which are anticipated to have some
evolutionary relation. Sequence alignment algorithms are primarily used for
constructing phylogenetic trees, searching for homologous sequences with BLAST,
assembling full DNA strands from short reads, creating input features for
AlphaFold2 and other.

Most alignment algorithms try to maximize a so called \emph{scoring function},
which assigns to a given alignment some score. The classical methods score
alignments by summing up scores assigned to each pair of letters in the given
alignment. The scores for the pairs of letters can be represented by a
symmetric matrix --- we call such matrices "\emph{scoring matrices}".

\begin{definition}
    The following will be used throughout the paper:
    \begin{itemize}
        \item A \emph{sequence} $s$ is an ordered collection of letters from
              an alphabet $\mathcal{L}$.
        \item The letter '\texttt{-}' is called \emph{indel} and represents
              gaps in the alignment, which occur due to mutations or sequencing
              errors.
      \item A pairing of two nuleotides $a, b$ is called a "\emph{match}" if $a = b$, a "\emph{mistmatch"} if $a \ne b$ and a "\emph {gap}" if $a =$ "\texttt{-}" or $b =$ "\texttt{-}",

        \item A \emph{sequence alignment} is a matrix $\mathbf A \in
                  (\mathcal{L} + \{\mathtt{-}\})^{n \times m}$, where $m$ is the
              length of the alignment and $n$ is the number of aligned sequences.
	      An alignment with $n = 2$ is called a \emph{pairwise sequence alignment.}
      \item A scoring function $\sigma: (\mathcal{L} + \{\mathtt{-}\})^{2
                      \times m} \to \mathbb{Z}$ maps an alignment to its score.
    \end{itemize}
\end{definition}

The typical algorithms for pairwise sequence alignment use a scoring function of the form
$\sigma_s( \mathbf A )= \sum_{j=0}^m s(\mathbf A_{1j}, \mathbf A_{2j})$, where $s:
    (\mathcal L + \{\mathtt{-}\})^2 \to \mathbf{Z}$ is a symmetric function
evaluating pairs of letters, which can be represented by a matrix $\mathbf S
    \in \mathbb Z^{(\# \mathcal L) + 1 \times (\# \mathcal L) + 1}$. Said matrix is
the focus of this work.

\begin{example}
    Our alphabet of concern will be the 4
    different nucleotide bases, \{\texttt{A, C, G, T}\}. Two exemplary DNA
    sequences are \texttt{ACA} and \texttt{AAGA}. One possible alignment between them is
    \begin{equation*}
        \mathbf A = \begin{bmatrix}
            \mathtt{A} & \mathtt{C} & \mathtt{-} & \mathtt{A} \\
            \mathtt{A} & \mathtt{A} & \mathtt{G} & \mathtt{A}
        \end{bmatrix}
    \end{equation*}
    An exemplary scoring matrix might be
    \begin{equation*}
        \mathbf S = \begin{matrix}
             & \mathtt{A} & \mathtt{C} & \mathtt{G} & \mathtt{T} &
            \mathtt{-}                                             \\ \mathtt{A} & 1          & -2         & -3         & 0
             &
            0
            \\ \mathtt{C} & -2         & 0          & 0          & 0
             & 0
            \\ \mathtt{G} & -3         & 0          & 0          & 0
             & -4
            \\ \mathtt{T} & 0          & 0          & 0          & 0
             & 0
            \\ \mathtt{-} & 0          & 0          & -4         & 0
             & 0
            \\
        \end{matrix}
    \end{equation*}
    Using the above matrix, \begin{align}
	    \sigma_{\mathbf S}(\mathbf A) &= s(\mathtt A, \mathtt A) + s(\mathtt C, \mathtt A) + s(\mathtt{-}, \mathtt{G}) + s(\mathtt{A}, \mathtt{A}) \\
					  &= 1 - 2 -4 + 1 \\
					  &= -6.
    \end{align}
\end{example}

\subsubsection*{BLOSUM}
Famously, one family of scoring matrices are the so called BLOSUM (\textbf{BLO}ck \textbf{SU}bstitution \textbf{M}atrices), first constructed by \textcite{henikoffAminoAcidSubstitution1992} for aligning amino acid sequences. A wonderful explanation thereof was written by
\textcite{eddyWhereDidBLOSUM622004}, however, we shall briefly dive into the
theoretical underpinnings of BLOSUM here as well.

Underlying BLOSUM is the equation that, given the two paired letters $a \in
    \mathcal L, b \in \mathcal L$,
\begin{equation*}
    s(a, b)= 2 \log_2 \frac{P(a, b)}{P(a)P(b)}.
\end{equation*}

We can understand this as follows: We want to derive a score we assign
for aligning the two letters $a$ and $b$, $s(a,b)$. We can represent such
a score by the odds of the probability of alignment being observed in nature, $P(a, b)$, over the probability of the two being paired due to chance $P(a \cup b) = P(a)P(b)$.

Now, assuming we have a dataset with already aligned data we deem to be good, we
can approximate $P(a, b)$ by counting how often $a, b$ were aligned, and we can
also approximate $P(a)*P(b)$ by counting how often both $a$ and $b$ appear
individually and multiplying the two counts.

The orgiginal BLOSUM matrices used the Blocks database
\cite{henikoffAutomatedAssemblyProtein1991} which provided multiple sequence
alignments (MSAs) without any gaps, from which $P(a, b)$ and $P(a)$ and $P(b)$
were approximated from. Blocks are conserved regions of multiple sequence alignments without
gaps. Thus, the resulting scoring matrix does not include values for gaps. We now follow up with
a somewhat precise definition of a simplified version of the algorithm to compute the BLOSUM matrices.

\begin{definition}
A Blocks database $\mathbf Z$ is a sequence of MSAs of differing shapes, i.e., $\mathbf Z = (\mathbf A^k)_{k=1}^l$
	Let $\mathbf C \in \mathbb N^{4 \times 4}$ be a symmetric matrix
which counts how often each nucleotide was aligned to another nucleotide in each column of each block.
Let $\mathbf Q$ be the matrix of the relative frequencies of the observed pairs, i.e.,
\begin{equation*}
	 \mathbf Q_{i, j} = \mathbf C_{i, j} / \sum_i^4 \sum_j^i \mathbf C_{i, j}j
\end{equation*}
Further, we denote the relative frequencies of each nucleotide in $\mathbf Z$ as $\mathbf p$, and it can
be computed from $\mathbf Q$ via $\mathbf p_i = \mathbf Q_{i, i} + \sum_{j \ne i, j = 0}^4 \frac {\mathbf Q_{i, j}} {2}$.
\end{definition}
\begin{example}
	Let $\mathbf Z$ consist of two blocks:
	\begin{equation*}
		\begin{matrix}
		\begin{matrix}
			\texttt{AA} \\
			\texttt{AC} \\
			\texttt{AC} \\
		\end{matrix} &
		\begin{matrix}
			\texttt{AA} \\
			\texttt{AC} \\
			\texttt{AC} \\
		\end{matrix}.
	\end{matrix}
	\end{equation*}
	For the first block, we would have in the first column three pairs of \texttt{AA}, and in the second column two pairs of \texttt{AC} and one pair of \texttt{CC}
	The second block is identical, so the counts are thus identical. We thus get
	\begin{equation*}
		\mathbf C = \begin{bmatrix}
			6 & 4 & 0 & 0 \\
			4 & 2 & 0 & 0 \\
			0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0
		\end{bmatrix}
	\end{equation*}
	From this, we get
	\begin{equation*}
		\mathbf Q = \begin{bmatrix}
			0.5 & 0.33 & 0 & 0 \\
			0.33 & 0.16 & 0 & 0 \\
			0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0
		\end{bmatrix}
	\end{equation*}
	and
	\begin{equation*}
		\mathbf p = \begin{bmatrix}
			0.66 & 0.33 & 0 & 0
		\end{bmatrix}
	\end{equation*}
\end{example}

Now the assumption is that, given that $i$ is the index of $a$ and $j$ is the index of $b$,
\begin{equation*}
	s(a, b) \approx	2 \log_2 \begin{cases}
		\frac{\mathbf Q_{i, j}}{2p_ip_j} & i \ne j, \\
		\frac{\mathbf Q_{i, j}}{p_i^2} & i = j
	\end{cases}
\end{equation*}
--- rounding these values to the nearest integer then gives us our scoring matrix $\mathbf S$.

\begin{remark}
	One rightfully might ask the question why the odds are put through a logarithm of base 2 and subsequently multiplied by 2.
	The logarithm of odds (called \emph{log-odds} are fairly standard in statistics --- odds are by definition positive, and "bad odds", i.e., those where the numerator is smaller than the denominator, span only $(0, 1)$, whereas good odds have a range of $[1, \infty)$. $\frac x y \ne -\frac y x$ but $\log \frac x y = - \log \frac y x $.
	\end{remark}

An important piece of the algorithm is still missing - the clustering of sequences within blocks.
We will introduce this more informally: we pick a similarity threshold $x$, we
then check within each block which sequences have $\ge x$\% identity and
then 'average' the the sequences, transitively, i.e., if sequence $i$ and
sequence $j$ are to be clustered and sequence $j$ and sequence $k$ as well,
then sequence $i$, sequence $j$ and sequence $k$ are being clustered together.
The count matrix $\mathbf C$ now includes fractional counts, and the rest of the computation remains the same.

\begin{example}
	Let
	\begin{equation*}
		\mathbf A = \begin{matrix}
			\mathtt{AAC} \\
			\mathtt{AGC} \\
			\mathtt{AGG} \\
			\mathtt{TTT}
		\end{matrix}	
	\end{equation*}
	and $x = \frac 2 3$. Sequences $(1, 2)$ and $(2, 3)$ exceed the similarity threshold,
	thus the clustered block will be
	\begin{equation*}
		c(\mathbf A) = \begin{matrix}
		\mathtt{A}(\frac 2 3 \mathtt G \frac 1 3 \mathtt A)(\frac 2 3 \mathtt C \frac 1 3 \mathtt G) \\	
		\mathtt{TTT}
		\end{matrix} 	
	\end{equation*}
	The resulting count matrix 
	\begin{equation*}
			\mathbf C = \begin{bmatrix}
			0 & 0 & 0 & \frac 4 3 \\
			0 & 0 & 0 & \frac 2 3 \\
			0 & 0 & 0 & 1 \\
			\frac 4 3 & \frac 2 3 & 1 & 0
		\end{bmatrix}.
	\end{equation*}
\end{example}
This amounts to the basic machinery of the algorithm to compute BLOSUM matrices.

This family of matrices has become a de-facto standard for aligning amino acid
sequences - however, not so much for DNA. BLASTn, i.e., BLAST for nucleotide bases, currently uses a matrix where
matches are rewarded with +2 and mismatches are penalized with -3. It is this very assumed generality that has motivated this paper.

\begin{remark}
Interestingly enough, there have been
mistakes in the original computation of the BLOSUM matrices, which are claimed
to have been improving them quietly. This, however, might be attributed to the
fact that the benchmarks today might be influenced from the BLOSUM of the past.

\end{remark}

\begin{remark}
	The reader might notice that there is some form of circular reasoning going on around
	the computation of the BLOSUM matrices - good alignments are produced by using BLOSUM 
	matrices and BLOSUM matrices are produced by good alignments. Indeed, the BLOCKS database
	itself is created with BLOSUM matrices, and the two iteratively create the other.

	First, the BLOCKS database is created from a scoring matrix with 0 mismatch score and 1 match score. Then, the first BLOSUM matrix is created, which is then used to produce new blocks. This process is then done another 2 times until the actual BLOSUM matrix and BLOCKS database have been produced.
\end{remark}

\subsubsection*{Related work}
Most notably, the two families of classical scoring matrices are the PAM
matrices and the BLOSUM matrices. However, and this is also true for most other
research around sequence alignment: there is a strong emphasis on studying the
alignment of proteins over studying the alignment of DNA. To the best of our
knowledge, nearly all benchmarks concern \emph{only amino acid alignments}, which
we suspect to to be one of the reasons that there is limited research focusing
on DNA alignment. There have been attempts to create gold standards for RNA
alignment,
however, even there, investigations suggest an overrepresentation of tRNA, thus
leading to a suboptimal benchmark.

The literature for DNA scoring matrices derived from data is sparse.
\textcite{hamadaTrainingAlignmentParameters2017} derive scoring matrices from
specific organisms sequenced by specific sequencers. Further, as they claim,
different genes in different organisms have significantly differing rates of
mutation, which is why general-purpose DNA scoring matrices might be a bad
idea. Their main focus lies on recovering and mitigating the sequencing errors
and projecting the differing GC contents of different species in the resulting
matrix. They evaluate their data on simulated data, which consequentually makes
strong assumptions, thus is not too optimal. Their method performs slightly
better than 2 manually created scoring matrices.


\section*{Experiments and results}
\subsection*{Method}
We constructed a fully automated pipeline which takes as input an identification code of a protein
family on InterPro and the similarity threshold $x$ and computes the
corresponding BLOSUMx matrix. The source code can be found online, yet, here we
give some detail on the implementation and issues we faced.

First, we search the NCBI protein database for the given identification code
using eDirect. This yields only a subset of the desired genes, since not every
protein in the database is annotated with all protein family codes. It is
however, to the best of our knowledge, the fastest and most reliable way to
download genes of a given protein family on InterPro. For the scope of this
work, we deem this sufficient.

Next, the downloaded genes are preprocessed. Genes which contain elements
besides \texttt{ACGT} are removed. Then, the genes are being sorted into bins,
depending on their length, the rationale thereof being that most multiple
sequence alignments assume that the sequences are of similar length. Further,
bins which have too few sequences in them are also being removed.

Unfortunately, the PROTOMAT system originally used by Heinikoff is not to be
found online any longer. Thus, we create our own blocks, which is clearly a
major difference to the construction of the orgininal BLOSUM matrices.

NOTE: BLAST should provide Web interface for Matrix.
To do so, each bin is getting aligned by kalign (Use different software?) with
its default settings. This results in an MSA for each bin.

Thereafter, each MSA is looked at and columns which contain less than a certain
percentage of gaps are selected. Then, from the `dense' columns, we find blocks
of adjacent dense columns. These will be the blocks for the computation of the
BLOSUMx matrix. This is a somewhat

substantial difference: the blocks in the original paper are \textbf{gapless},
whereas the blocks in this paper \textbf{contain some gaps}.

\end{multicols}

\begin{figure}
	\centering
\includegraphics[scale=0.9]{plots/downprojection.pdf}
	\caption{Various nkBLOSUM matrices derived from the specific protein families for different subsets of species, projected to two dimensions using PCA. The protein family is indicated by symbol and the species indicated by color.}
\end{figure}
\include{plots/table.tex}
\include{plots/matrices.tex}
\printbibliography
\end{document}
