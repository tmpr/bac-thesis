\documentclass{article}

% -- Packages
\usepackage[utf8]{inputenc}
\usepackage{biblatex}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{microtype}
\usepackage{pdfpages}
\usepackage{{booktabs}}
\usepackage{{multirow}}
\usepackage{geometry}
\usepackage{bookmark}
\usepackage{multicol}

% -- Theorem environments
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}

% -- Document Settings
\emergencystretch=1em
\title{Deriving BLOSUM-like matrices for protein-coding DNA}
\geometry{a4paper, left=20mm, right=20mm, top=20mm, bottom=30mm}
\addbibresource{substitution-matrices.bib}
\author{Alexander Temper}

\begin{document}
\maketitle

\begin{abstract}
    Sequence Alignment algorithms rely on some form of scoring matrix,
    which can heavily influence their results. In this work, we try to derive a
    scoring matrices for the genes of subsets of protein families akin to
    the BLOSUMx matrices, which are used for amino acid sequences.
\end{abstract}

\begin{multicols}{2}
	
\section*{Introduction} Sequence alignment is the task of pairing up the
elements of two (biological) sequences with the aim of finding conserved
regions and homologous sequences which are anticipated to have some
evolutionary relation. Sequence alignment algorithms are primarily used for
constructing phylogenetic trees, searching for homologous sequences with BLAST,
assembling full DNA strands from short reads, creating input features for
AlphaFold2 and other.

Most alignment algorithms try to maximize a so called \emph{scoring function},
which assigns to a given alignment some score. The classical methods score
alignments by summing up scores assigned to each pair of letters in the given
alignment. The scores for the pairs of letters can be represented by a
symmetric matrix --- we call such matrices "\emph{scoring matrices}".

We formally define our vocabulary. W.l.o.g., we restrict ourselves to pairwise
alignments, i.e., alignments of two sequences.

\begin{definition}
    The following will be used throughout the paper:
    \begin{itemize}
        \item A \emph{sequence} $s$ is an ordered collection of letters from
              an alphabet $\mathcal{L}$.
        \item The letter '\texttt{-}' is called \emph{indel} and represents
              gaps in the alignment, which occur due to mutations or sequencing
              errors.
      \item A pairing of two nuleotides $a, b$ is called a "\emph{match}" if $a = b$, a "\emph{mistmatch"} if $a \ne b$ and a "\emph {gap}" if $a =$ "\texttt{-}" or $b =$ "\texttt{-}",

        \item A (pairwise) \emph{sequence alignment} is a matrix $\mathbf A \in
                  (\mathcal{L} + \{\mathtt{-}\})^{2 \times m}$, where $m$ is the
              length
              of the alignment.
      \item A scoring function $\sigma: (\mathcal{L} + \{\mathtt{-}\})^{2
                      \times m} \to \mathbb{Z}$ maps an alignment to its score.
    \end{itemize}
\end{definition}

Most algorithms of concern here use a scoring function of the form
$\sigma_s( \mathbf A )= \sum_{j=0}^m s(\mathbf A_{1j}, \mathbf A_{2j})$, where $s:
    (\mathcal L + \{\mathtt{-}\})^2 \to \mathbf{Z}$ is a symmetric function
evaluating pairs of letters, which can be represented by a matrix $\mathbf S
    \in \mathbb Z^{(\# \mathcal L) + 1 \times (\# \mathcal L) + 1}$. Said matrix is
the focus of this work.

\begin{example}
    Our alphabet of concern will be the 4
    different nucleotide bases, \{\texttt{A, C, G, T}\}. Two exemplary DNA
    sequences are \texttt{ACA} and \texttt{AAGA}. One possible alignment between them is
    \begin{equation*}
        \mathbf A = \begin{bmatrix}
            \mathtt{A} & \mathtt{C} & \mathtt{-} & \mathtt{A} \\
            \mathtt{A} & \mathtt{A} & \mathtt{G} & \mathtt{A}
        \end{bmatrix}
    \end{equation*}
    An exemplary scoring matrix might be
    \begin{equation*}
        \mathbf S = \begin{matrix}
             & \mathtt{A} & \mathtt{C} & \mathtt{G} & \mathtt{T} &
            \mathtt{-}                                             \\ \mathtt{A} & 1          & -2         & -3         & 0
             &
            0
            \\ \mathtt{C} & -2         & 0          & 0          & 0
             & 0
            \\ \mathtt{G} & -3         & 0          & 0          & 0
             & -4
            \\ \mathtt{T} & 0          & 0          & 0          & 0
             & 0
            \\ \mathtt{-} & 0          & 0          & -4         & 0
             & 0
            \\
        \end{matrix}
    \end{equation*}
    Using the above matrix, \begin{align}
	    \sigma_{\mathbf S}(\mathbf A) &= s(\mathtt A, \mathtt A) + s(\mathtt C, \mathtt A) + s(\mathtt{-}, \mathtt{G}) + s(\mathtt{A}, \mathtt{A}) \\
					  &= 1 - 2 -4 + 1 \\
					  &= -6.
    \end{align}
\end{example}

\subsubsection*{BLOSUM}
Famously, one family of scoring matrices are the so called BLOSUM (\textbf{BLO}ck \textbf{SU}bstitution \textbf{M}atrices), first constructed by \textcite{henikoffAminoAcidSubstitution1992} for aligning amino acid sequences. A wonderful explanation thereof was written by
\textcite{eddyWhereDidBLOSUM622004}, however, we shall briefly dive into the
theoretical underpinnings of BLOSUM here as well.

Underlying BLOSUM is the equation that, given the two paired letters $a \in
    \mathcal L, b \in \mathcal L$,
\begin{equation*}
    s(a, b)= 2 \log_2 \frac{P(a, b)}{P(a)P(b)}.
\end{equation*}

We can understand this as follows: We want to derive a score we assign
for aligning the two letters $a$ and $b$, $s(a,b)$. We can represent such
a score by the odds of the probability of alignment being observed in nature, $P(a, b)$, over the probability of the two being paired due to chance $P(a \cup b) = P(a)P(b)$.

Now, assuming we have a dataset with already aligned data we deem to be good, we
can approximate $P(a, b)$ by counting how often $a, b$ were aligned, and we can 
also approximate $P(a)*P(b)$ by counting how often both $a$ and $b$ appear 
individually and multiplying the two counts.

The orgiginal BLOSUM matrices used the Blocks database
\cite{henikoffAutomatedAssemblyProtein1991} which provided multiple sequence
alignments (MSAs) without any gaps, from which $P(a, b)$ and $P(a)$ and $P(b)$
were approximated from. Note here that this assumed

This family of matrices has become a de-facto standard for aligning amino acid
sequences - however, not so much for DNA. BLASTn, i.e., BLAST for nucleotide bases, currently uses a matrix where
matches are rewarded with +2 and mismatches are penalized with -3. It is this very assumed generality that has motivated this paper.
Interestingly enough, there have been
mistakes in the original computation of the BLOSUM matrices, which are claimed
to have been improving them quietly. This, however, might be attributed to the
fact that the benchmarks today might be influenced from the BLOSUM of the past.
\subsubsection*{Related work}

Most notably, the two families of classical scoring matrices are the PAM
matrices and the BLOSUM matrices. However, and this is also true for most other
research around sequence alignment: there is a strong emphasis on studying the
alignment of proteins over studying the alignment of DNA. To the best of our
knowledge, nearly all benchmarks concern \emph{only amino acid alignments}, which
we suspect to to be one of the reasons that there is limited research focusing
on DNA alignment. There have been attempts to create gold standards for RNA
alignment,
however, even there, investigations suggest an overrepresentation of tRNA, thus
leading to a suboptimal benchmark.

The literature for DNA scoring matrices derived from data is sparse.
\textcite{hamadaTrainingAlignmentParameters2017} derive scoring matrices from
specific organisms sequenced by specific sequencers. Further, as they claim,
different genes in different organisms have significantly differing rates of
mutation, which is why general-purpose DNA scoring matrices might be a bad
idea. Their main focus lies on recovering and mitigating the sequencing errors
and projecting the differing GC contents of different species in the resulting
matrix. They evaluate their data on simulated data, which consequentually makes
strong assumptions, thus is not too optimal. Their method performs slightly
better than 2 manually created scoring matrices.


\section*{Experiments and results}
\subsection*{Method}
We constructed a fully automated pipeline which takes as input an identification code of a protein
family on InterPro and the similarity threshold $x$ and computes the
corresponding BLOSUMx matrix. The source code can be found online, yet, here we
give some detail on the implementation and issues we faced.

First, we search the NCBI protein database for the given identification code
using eDirect. This yields only a subset of the desired genes, since not every
protein in the database is annotated with all protein family codes. It is
however, to the best of our knowledge, the fastest and most reliable way to
download genes of a given protein family on InterPro. For the scope of this
work, we deem this sufficient.

Next, the downloaded genes are preprocessed. Genes which contain elements
besides \texttt{ACGT} are removed. Then, the genes are being sorted into bins,
depending on their length, the rationale thereof being that most multiple
sequence alignments assume that the sequences are of similar length. Further,
bins which have too few sequences in them are also being removed.

Unfortunately, the PROTOMAT system originally used by Heinikoff is not to be
found online any longer. Thus, we create our own blocks, which is clearly a
major difference to the construction of the orgininal BLOSUM matrices.

NOTE: BLAST should provide Web interface for Matrix.
To do so, each bin is getting aligned by kalign (Use different software?) with
its default settings. This results in an MSA for each bin.

Thereafter, each MSA is looked at and columns which contain less than a certain
percentage of gaps are selected. Then, from the `dense' columns, we find blocks
of adjacent dense columns. These will be the blocks for the computation of the
BLOSUMx matrix. This is a somewhat

substantial difference: the blocks in the original paper are \textbf{gapless},
whereas the blocks in this paper \textbf{contain some gaps}.

\end{multicols}

\begin{figure}
	\centering
\includegraphics[scale=0.95]{plots/downprojection.pdf}
	\caption{Various nkBLOSUM matrices derived from the specific protein families for different subsets of species, projected to two dimensions using PCA. The protein family is indicated by symbol and the species indicated by color.}
\end{figure}
\include{plots/table.tex}
\include{plots/matrices.tex}
\printbibliography
\end{document}
